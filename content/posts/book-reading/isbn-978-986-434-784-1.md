---
title: "[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求"
date: 2022-12-03
lastmod: 2023-01-12
draft: false
authors: ["nofear195"]
description: ""

categories: ["book-reading"]
series: ["object oriented","software development"]

lightgallery: true

---

ISBN 978-986-434-784-1 (1.物件導向 2.軟體研發)
<!--more-->

## 物件導向理論

### 類別(class)

- 概念：一組相似事物的統稱
  - 一組：多個
  - 相似：比較像，但不完全相同
  - 統稱：通稱，概括多個事物

- 劃分方法：站在個人的觀察角度，察覺有相似的事物就是同一類

- 組成：
  1. 屬性：類別的特性
     - 原則：最小化原則，將屬性切到無法在分割為止
  2. 方法：類別的功能
     - 原則：單一化原則，一個方法只做一件事

### 物件(object)

- 概念：一個具體、真實存在的類別

- (軟體)物件產生的流程方法 (水果 -> 蘋果、香蕉)
  - 現實物件：可觀察到現實存在的物體
  - 現實類別：對現實物體的歸納總結
  - 軟體物件：軟體運行時的實體
  - 軟體類別：軟體設計過程中的歸納總結而成的分類
  1. 觀察現實存在的物件，歸納概括成現實的類別
    {{< mermaid >}}graph LR;
        A(現實物件) -->|歸納概括| B(現實類別)
    {{< /mermaid >}}
  2. 根據現實的類別，在軟體設計的過程中，歸納總結的分類成果
    {{< mermaid >}}graph RL;
        B(現實類別) -->|抽象模擬| C(軟體類別)
    {{< /mermaid >}}
  3. 實體化在軟體運行中的實體
    {{< mermaid >}}graph LR;
        C(軟體類別) -->|實體化| D(軟體物件)
        D -->|互動| E(程式)
    {{< /mermaid >}}
{{< mermaid >}}graph LR;
    A(現實物件) -->|歸納概括| B(現實類別)
    B -->|抽象模擬| C(軟體類別)
    C -->|實體化| D(軟體物件)
    D -->|互動| E(程式)
{{< /mermaid >}}

- 實作技巧
  - 概念：電影來自生活，但高於生活 => 軟體類別來自現實類別，但高於現實類別
  - 可以用多個軟體類別，組成一個對應的現實類別 (可不用一對一)
    - eg: (現實類別) ATM 功能 = (軟體類別) ATM 餘額查詢 ＋ ATM 取款 ＋ ATM 存款
  - 軟體類別因為是抽象模擬的 “概念”，所以並不一定存於現實中
    - eg: 策略 strategy，工作流程 workflow

### 介面(interface)

- 概念：一組相關、有互動功能的點集合
  - inter：互相，兩方的互動
  - face：面，點的集合，相對應於點、線

- 定義概念拆解：
  1. 相關：彼此相關的功能作用，eg: USB 介面、網路介面、
  2. 互動：可作用於不同物體之間的互動，非單一方面
  3. 定義：只做定義，但不涉具體實作 => 一個互動雙方的“約定”，具體的實作方式由實際互動方制定即可
  4. 集合：多個功能點的集合，非一個具體的功能點

- 特性：
  - 在希望某群物件有共同的屬性或功能下使用
  - 在不清楚某群物件是否屬於同一個類別下使用
  - eg: 在面對處理的物體是動物，但又希望這個動物按照所需求的方式進行活動 (人、狗、其他動物)

### 抽象(abstract)

- 概念：抽取比較像的部分出來

- 結合物件的概念：抽取多個物件或類別中比較像的部分

- 特性：
  - 可劃分具有“相似”的類別
  - 主要目的：隔離關注點，降低複雜度
  - 主要用於發現新類別的方法 => 先抽象共同點，在拉出一個新的類別
  - eg: (developer,maintainer)=> people, (developer,dog) => animal

### 抽象類別(abstract class)

- 概念：根據類別共有的特性，再進行抽取比較像的部分

- 特性：
  - 本質上還是類別，但只能用於繼承，無法用來產生實體的物件
  - 相對於普通的軟體類別由現實類別抽象模擬而出，抽象類別則是更高級的抽象
  - 抽象類別是由普通軟體類別抽象模擬而成
  - eg: 吃“水果”(抽象類別)，實際上是吃“蘋果、香蕉”(普通類別)
  - 同時具備普通類別與介面的部分特性，為介於兩者之間的概念

- 與普通類別的差異：
  - 繼承：
    - 普通類別：子類別透過繼承父類別，即可獲得父類別的方法
    - 抽象類別：若有定義抽象方法(只有宣告，但沒有實作)，則子類別需要自己去實作方法

- 與介面的差異：
  - 概念：
    - 介面：強調物件之間的相似性，但僅限於方法宣告，缺少定義上的相似
    - 抽象類別：為類別，強調一組事物的相似性，包含屬性與方法
  - 實作：
    - 介面：需要逐一實作個別物件的屬性與方法
    - 抽象類別：若有定義抽象方法，則需要為繼承的物件個別實作

### 物件導向核心特徵

1. 封裝 (encapsulation)
   - 概念：使用類別，將一組相似事物的特性與行為包裝起來
   - 作用：
     - 保護隱私
       - 對類別內個屬性的修改，只能通過內部的類別方法存取
     - 隔離複雜度
       - 個別類別只需負責自己的實作功能即可
       - 類別外在的使用者，只需呼叫類別提供的方法即可，不需了解其內部的實作方法
   - 方法：
     - public：不進行封裝，直接對外公開
     - protected：只對 child,與 friend 類別公開
     - private：完全不公開

2. 繼承 (inheritance)
   - 概念：遺傳，承襲 parent 的特性與行為
   - 與抽象的差異
     - 抽象: 分析和設計過程的一個動作、一個技巧，透過抽象出類別
     - 繼承: 實作過程的一個動作，根據抽象的結果，透過程式語言的特性，完成抽象的模擬
     - 抽象與繼承的關係：“承先啟後”，先有抽象，再由抽象得出類別，最後由繼承表達抽象的結果

3. 多型(polymorphism)
   - 概念：“多胎”，使用指向父類別的指標或參考，便能呼叫子類別的物件
   - 特性：
     - 遮罩對於子物件的差異，允許呼叫者撰寫通用性的程式碼
     - 當呼叫函式時，帶入指定為 parent 的類型時，可以帶入 children 的物件屬性，並在內部使用 parent 定義的函式

## 物件導向方法

### 物件導向開發流程

1. 需求模型：透過和客戶溝通，結合行業經驗和知識，明確刻畫客戶的需求

2. 領域模型：根據需求模型，提煉出領域相關的概念，為後面的物件導向設計打下基礎

3. 設計模型：以領域模型為基礎，綜合物件導向的各種設計技巧，完成類別的設計

4. 實作模型：以設計模型為基礎，將設計模型轉譯為具體的語言實作，完成程式碼的撰寫

{{< mermaid >}}graph LR;
        A(需求模型) --> B(領域模型)
        B --> C(現設計模型)
        C --> D(實作模型)
{{< /mermaid >}}

### 需求模型

### 領域模型

### 設計模型

### 實作模型

## 物件導向技巧

### 設計原則

1. 內聚(Cohesion)
   - 概念：“凝聚力”，模組 (函數、類別、套件、子系統) 內的元素，是否都專注於模組所賦予的職責
   - 較佳的內聚形式：功能內聚
     - 案例概念：進行 CRUD 操作的類別，內部的元素間雖沒相關互動，但皆專注於資料的操作與存取

2. 耦合(Coupling)、依賴(Dependency)
   - 概念：模組間的依賴程度，某個模組Ａ使用了另一個模組Ｂ的元素完成特定功能
   - 最差的耦合形式：內容耦合
     - 概念：模組Ｂ修改模組Ａ所依賴的內容(屬性)時，模組Ａ跟模組Ｂ都必須同步修改

3. 設計原則：高內聚低耦合
   - 目的：降低複雜性
   - 反向思維：低內聚 or 高耦合 會使系統產生較多的不確性，即不穩定
   - 實作想法：在高內聚與低耦合間取得平衡，不偏向任何一端

#### 類別設計原則 S.O.L.I.D. principle

1. SRP (Single Responsibility Principle, 單一職責原則)
   - 概念：一組類別只需負責一組 "相關" 的事, 即一個類別有多個方法，且相互關聯
   - 職責定義：
     1. 由其他的類別視角來決定
     2. 包含多個相關的功能
   - 適用範圍：基礎類別
   - 不適用範圍 : 聚合類別 (根據基礎類別建構的複雜結構)。
     - 解法：優先使用多物件作組合，而非類別繼承
   - 應用場景：用於類別的設計

2. OCP (Open-Closed Princle, 開放封閉原則)

3. LSP (Liskov Substitution Principle, Liskov 替換原則)

4. ISP (Interface Seggregation Principle, 介面隔離原則)

5. DIP (Dependency Inverse Principle, 依賴注入原則)

### 設計模式

### UML

