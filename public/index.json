[{"categories":["book-reading"],"content":"ISBN 978-986-357-208-4 (1.心理治療) infomation 譯自： The Gift of Therapy : An Open Letter to a New Generation of Therapists and Their Patients - Irvin D. Yalon ","date":"2023-01-11","objectID":"/my-hugo-blog/the-gift-of-the-therapy/:0:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  生命的禮物 給心理治療師的 85 則備忘錄","uri":"/my-hugo-blog/the-gift-of-the-therapy/#"},{"categories":["book-reading"],"content":" 心得 雖非從事心理治療相關的職業，但還是從中收穫了許多，由其是從心理治療師的視角看待每次治療的過程，真的非常不一樣，非常有趣 ","date":"2023-01-11","objectID":"/my-hugo-blog/the-gift-of-the-therapy/:1:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  生命的禮物 給心理治療師的 85 則備忘錄","uri":"/my-hugo-blog/the-gift-of-the-therapy/#心得"},{"categories":["book-reading"],"content":" 佳句節錄 尼采 : 人愛上的是自己的慾望，而不是所欲的對象 心理治療中，有四種終極關懷是非常顯著的，就是死亡、孤獨、人生的意義、自由 我們是自己的作者。透過增加自己的選擇、自己的行動以及缺乏行動，我們最終描繪出自己。我們無法逃避這種責任，這種自由。- 我們注定是自由的。 責任的承擔是治療過程不可或缺的第一步，一旦能體認到自己在生活困境的產生過程中，扮演了什麼角色，就能理解自己有改變處境的力量 每件事都會逐漸逝去，唯有選擇除外 - Grendel (小說 : 格倫德爾) 存在治療實務中的兩大面向 內容 : 說出的話、使用的字句、所談的具體議題 過程 : 病人與治療師之間的關係 『 此時此地 』所發生的每一件事，都可在治療中運用 此時此地運用的理由，存在兩種假設 (人的問題大部分是關係的問題，而個人的人際問題最後會出現在此時此地之中) 人際關係的重要性 治療是社交縮影的概念 要有耐心面對每一件無法解決的事，試著去愛那些難題，也去愛那些提出問題的人 我們都有陰暗面 - 願意接受自己的陰暗面、不光彩的部分，在適當的時候分享出來，就能使病人不再為了自己真實或想像的罪過而自責 夢可以是有效的治療中無價的工具，夢代表病人深處問題的敏銳敘述，只是用不同的語言，一種視覺意象的語言 佛洛依德相信最初的夢常常是無價之寶，特別容易看見核心問題，因為病人潛意識中編織的人仍然天真無邪，比較沒有警戒心。經過一段時間的治療後，治療師展現解釋夢的能力，夢就會變得更為複雜難辨 病人多年後回顧治療的經驗時，會記得既不是洞察力，也不是治療師的解釋，而是治療師所說的正向支持的話 想要學習好好活著，就要學習好好死去 就如佛陀所教導的，對生命的意義的疑問是無意的，人必須讓自己沈浸在生命的流水中，讓疑問隨流而逝 心理治療並不能代替生活，而是生活的彩排。雖然心理治療需要親近的關係，但關係並不是目標，而是達到目標的方法 ","date":"2023-01-11","objectID":"/my-hugo-blog/the-gift-of-the-therapy/:2:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  生命的禮物 給心理治療師的 85 則備忘錄","uri":"/my-hugo-blog/the-gift-of-the-therapy/#佳句節錄"},{"categories":["learning-note"],"content":"For more practice code, please click the github repository –\u003e https://github.com/nofear195/ts-design-pattern 😄 😄 😄 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:0:0","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#"},{"categories":["learning-note"],"content":" Reference 7天學會設計模式：設計模式也可以這樣學 書中程式碼範例撰寫語言為 JAVA 本篇文章參照書中程式碼，並依照練習需求改寫為用 TypeScript 撰寫 Jest + TypeScript：建置測試環境 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:1:0","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#reference"},{"categories":["learning-note"],"content":" Creational Patterns","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:0","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#creational-patterns"},{"categories":["learning-note"],"content":" Factory Practice code in TypeScrpt : Factory pattern Simple Factory 概念:建立一個 class(factory)，可隨著不同的輸入，取得相同抽象的類別實體 方法: 建立一個共同行為的抽象 (interface or class) 實作或繼承所需的類別 建立一個類別(factory) ，其中可藉由不同的輸入，返回特定實作抽象的類別實體 簡單工廠,又稱靜態工廠 優點:封裝類別實體的建立過程 缺點:違反 OCP 開放/封閉原則，加入新的類別時，會改動 factory 的內容 Factory 概念: 抽象化 factory 的概念，只定義 factory 產出的方法，具體實作由子類別各自實現 方法： 建立一個共同行為的抽象 interface or class 實作或繼承所需的類別 建立ㄧ個抽象(factory)，定義類別實體的方法 實作所需類別的 factory 實體的建立，只能由該 factory 類別產生 Abstract Factory 概念: 將產生實體所需要的相關功能(屬性,方法) 再各自進行抽象，形成一系列的 factory 方法： 建立額外功能的 factory 建立基礎實體類別的 factory, 並在其中實體化額外功能的 factory 實體的建立，一樣只能由該基礎 factory 類別產生 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#factory"},{"categories":["learning-note"],"content":" Factory Practice code in TypeScrpt : Factory pattern Simple Factory 概念:建立一個 class(factory)，可隨著不同的輸入，取得相同抽象的類別實體 方法: 建立一個共同行為的抽象 (interface or class) 實作或繼承所需的類別 建立一個類別(factory) ，其中可藉由不同的輸入，返回特定實作抽象的類別實體 簡單工廠,又稱靜態工廠 優點:封裝類別實體的建立過程 缺點:違反 OCP 開放/封閉原則，加入新的類別時，會改動 factory 的內容 Factory 概念: 抽象化 factory 的概念，只定義 factory 產出的方法，具體實作由子類別各自實現 方法： 建立一個共同行為的抽象 interface or class 實作或繼承所需的類別 建立ㄧ個抽象(factory)，定義類別實體的方法 實作所需類別的 factory 實體的建立，只能由該 factory 類別產生 Abstract Factory 概念: 將產生實體所需要的相關功能(屬性,方法) 再各自進行抽象，形成一系列的 factory 方法： 建立額外功能的 factory 建立基礎實體類別的 factory, 並在其中實體化額外功能的 factory 實體的建立，一樣只能由該基礎 factory 類別產生 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#simple-factory"},{"categories":["learning-note"],"content":" Factory Practice code in TypeScrpt : Factory pattern Simple Factory 概念:建立一個 class(factory)，可隨著不同的輸入，取得相同抽象的類別實體 方法: 建立一個共同行為的抽象 (interface or class) 實作或繼承所需的類別 建立一個類別(factory) ，其中可藉由不同的輸入，返回特定實作抽象的類別實體 簡單工廠,又稱靜態工廠 優點:封裝類別實體的建立過程 缺點:違反 OCP 開放/封閉原則，加入新的類別時，會改動 factory 的內容 Factory 概念: 抽象化 factory 的概念，只定義 factory 產出的方法，具體實作由子類別各自實現 方法： 建立一個共同行為的抽象 interface or class 實作或繼承所需的類別 建立ㄧ個抽象(factory)，定義類別實體的方法 實作所需類別的 factory 實體的建立，只能由該 factory 類別產生 Abstract Factory 概念: 將產生實體所需要的相關功能(屬性,方法) 再各自進行抽象，形成一系列的 factory 方法： 建立額外功能的 factory 建立基礎實體類別的 factory, 並在其中實體化額外功能的 factory 實體的建立，一樣只能由該基礎 factory 類別產生 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#factory-1"},{"categories":["learning-note"],"content":" Factory Practice code in TypeScrpt : Factory pattern Simple Factory 概念:建立一個 class(factory)，可隨著不同的輸入，取得相同抽象的類別實體 方法: 建立一個共同行為的抽象 (interface or class) 實作或繼承所需的類別 建立一個類別(factory) ，其中可藉由不同的輸入，返回特定實作抽象的類別實體 簡單工廠,又稱靜態工廠 優點:封裝類別實體的建立過程 缺點:違反 OCP 開放/封閉原則，加入新的類別時，會改動 factory 的內容 Factory 概念: 抽象化 factory 的概念，只定義 factory 產出的方法，具體實作由子類別各自實現 方法： 建立一個共同行為的抽象 interface or class 實作或繼承所需的類別 建立ㄧ個抽象(factory)，定義類別實體的方法 實作所需類別的 factory 實體的建立，只能由該 factory 類別產生 Abstract Factory 概念: 將產生實體所需要的相關功能(屬性,方法) 再各自進行抽象，形成一系列的 factory 方法： 建立額外功能的 factory 建立基礎實體類別的 factory, 並在其中實體化額外功能的 factory 實體的建立，一樣只能由該基礎 factory 類別產生 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#abstract-factory"},{"categories":["learning-note"],"content":" Singleton Practice code in TypeScrpt : Singleton pattern 概念: 為確保此類別只會產出一個物件，在建立該類別時，便實體化該物件，且需提供唯一存取的方法 方法: 建立 private 的屬性，並將實體化的物件 assign 給該屬性 建立 private 的 constructer，確保該物件不會再被實體化 建立 public static 方法，取得唯一的類別實體 若建立該物件實體需要花費龐大資源，則實體可以延後至該類別第一次被呼叫時進行實體化 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:2","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#singleton"},{"categories":["learning-note"],"content":" Builder Practice code in TypeScrpt : Builder pattern 概念: 建立一個 director(指揮者)類別，用來封裝並指揮一個由多個不同類別組成的複雜實體，其類別實體化過程的先後順序 方法: 拆解複雜實體的結構來源，找出其引入的類別實體 找出複雜實體在實體化過程中，其內部引入類別的使用順序 在 director 類別初始化中，放入一個尚未引入內別類別的複雜實體 在 director 類別中建立組成函式，並依照分析後的順序，逐一將需要引入的類別實體，放入 director 內部的複雜實體中 特色: 如同指派一個師傅，由他去指揮一個團隊去組裝一個機器人，由一個機器人空殼，至能作用各式功能的機器人助手 與 abstract factory pattern 的差異，在於 Builder pattern 強調其由無到有的 “順序” ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:3","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#builder"},{"categories":["learning-note"],"content":" Prototype Practice code in TypeScrpt : Prototype pattern 概念: 直接複製原有的物件，而非直接重新建立一個新的物件 方法: 使用 shallow copy (淺拷貝) 的方式，將新物件與舊物件指向共同的記憶體位置 使用 deep copy (深拷貝) 的方式，將舊物件的內容複製到不同的記憶體位置，指向給新的物件使用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:2:4","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#prototype"},{"categories":["learning-note"],"content":" Structural Patterns","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:0","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#structural-patterns"},{"categories":["learning-note"],"content":" Decorator Practice code in TypeScrpt : Decorator pattern 概念: 像俄羅斯娃娃般，如同 “同心圓” 般一層覆蓋一層，由小至大，在原有的功能上再包裹一層作用(功能) 方法: 建立一致功能的抽象方法 依照需求在不同的實作階層上，實作該共同功能 使用該類別的實體時，可動態依照實作類別，動態附加功能於實體上 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#decorator"},{"categories":["learning-note"],"content":" Adapter Practice code in TypeScrpt : Adapter pattern 概念: 一個轉接器的功能，讓原本無法作用功能的實體，載入另一個可執行功能的實體，使原本的實體可藉由載入的實體，去完成原本無法作用的功能 方法: 在 adapter 初始化中，放入之後需要轉接功能的實體 定義 function 函式, 用來呼叫需要轉接實體的功能 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:2","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#adapter"},{"categories":["learning-note"],"content":" Facade Practice code in TypeScrpt : Facade pattern 概念: 使用一個類別，用來封裝直接與各個子系統的功能，並可以製作一連串子系統之間的互動的功能 方法: 在 facade 類別的初始化中，放入所有會互相作用的類別實體 定義 function 函式, 用來定義內部類別實體的相互作用方式 特色: 封裝一個大系統中，各個子系統間的互動方式，外部行為者只需要跟 facade 的介面進行互動即可 如同遙控器一樣，整合各式的工具，供使用者可以方便去使用 web service 中的 MVC 架構即是採用此 pattern 的做法 為最常見且被應用的 pattern 之一 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:3","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#facade"},{"categories":["learning-note"],"content":" Composite Practice code in TypeScrpt : Composite pattern 概念: 用於處理樹狀結構的資料，即當資料有階層式的關係，而每個階層都可抽象出共同行為時 方法: 定義一個抽象,搜集階層中 node 共同擁有的行為或方法，讓所有實體的 node 都可以去繼承並實作 在 node 介面上加入 add, remove 等新增或刪除的方式，用於改變當前樹狀結構的方式 分別以各個階層所需要的實作方式進行實作，eg: root, child, leaf 等 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:4","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#composite"},{"categories":["learning-note"],"content":" Proxy Practice code in TypeScrpt : Proxy pattern Dynamic Proxy 概念: 為被代理的物件提供一個緩衝，讓被代理的物件完成初始化或某些動作前，執行其他的動作(代理) 方法: 將需要被代理的物件方法作為一個動態代理的抽象 實作抽象的行為，並在初始化中放入被代理的物件 讓 client 只能藉由動態代理的方式，呼叫被代理物件的方法 特色: 包覆需要代理的物件，使其可以有餘裕完成本身需要被執行方法或執行初始化 與 decorator pattern 方法不同在於 decorator 可以包裹很多層，而 proxy 一般只會包裹一層 可以將 decorator pattern 作為 proxy pattern 的延伸或特化版 Protect Proxy 概念: 為被代理的物件提供一種保護，限制外在行為對其的存取行為 方法: 分析需要被代理的對象物件不同行為，形成一個抽象 實作抽象的行為，並在初始化中放入被代理的物件 將需要限制存取行為的方法，回傳為一個空值或訊息，藉以限制被代理的物件其屬性被更改 特色: 當引用第三方撰寫的程式時，可藉由限制代理作為一個前置的保護方式，用來避免引用的程式被誤用或亂用，而造成非預期的副作用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:5","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#proxy"},{"categories":["learning-note"],"content":" Proxy Practice code in TypeScrpt : Proxy pattern Dynamic Proxy 概念: 為被代理的物件提供一個緩衝，讓被代理的物件完成初始化或某些動作前，執行其他的動作(代理) 方法: 將需要被代理的物件方法作為一個動態代理的抽象 實作抽象的行為，並在初始化中放入被代理的物件 讓 client 只能藉由動態代理的方式，呼叫被代理物件的方法 特色: 包覆需要代理的物件，使其可以有餘裕完成本身需要被執行方法或執行初始化 與 decorator pattern 方法不同在於 decorator 可以包裹很多層，而 proxy 一般只會包裹一層 可以將 decorator pattern 作為 proxy pattern 的延伸或特化版 Protect Proxy 概念: 為被代理的物件提供一種保護，限制外在行為對其的存取行為 方法: 分析需要被代理的對象物件不同行為，形成一個抽象 實作抽象的行為，並在初始化中放入被代理的物件 將需要限制存取行為的方法，回傳為一個空值或訊息，藉以限制被代理的物件其屬性被更改 特色: 當引用第三方撰寫的程式時，可藉由限制代理作為一個前置的保護方式，用來避免引用的程式被誤用或亂用，而造成非預期的副作用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:5","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#dynamic-proxy"},{"categories":["learning-note"],"content":" Proxy Practice code in TypeScrpt : Proxy pattern Dynamic Proxy 概念: 為被代理的物件提供一個緩衝，讓被代理的物件完成初始化或某些動作前，執行其他的動作(代理) 方法: 將需要被代理的物件方法作為一個動態代理的抽象 實作抽象的行為，並在初始化中放入被代理的物件 讓 client 只能藉由動態代理的方式，呼叫被代理物件的方法 特色: 包覆需要代理的物件，使其可以有餘裕完成本身需要被執行方法或執行初始化 與 decorator pattern 方法不同在於 decorator 可以包裹很多層，而 proxy 一般只會包裹一層 可以將 decorator pattern 作為 proxy pattern 的延伸或特化版 Protect Proxy 概念: 為被代理的物件提供一種保護，限制外在行為對其的存取行為 方法: 分析需要被代理的對象物件不同行為，形成一個抽象 實作抽象的行為，並在初始化中放入被代理的物件 將需要限制存取行為的方法，回傳為一個空值或訊息，藉以限制被代理的物件其屬性被更改 特色: 當引用第三方撰寫的程式時，可藉由限制代理作為一個前置的保護方式，用來避免引用的程式被誤用或亂用，而造成非預期的副作用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:5","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#protect-proxy"},{"categories":["learning-note"],"content":" Bridge Practice code in TypeScrpt : Bridge pattern 概念: 將類別的抽象與實作方式做切分，讓各自的行為變化不會被相互引響 方法: 在抽象類別中，加入其他的類別，由其他的類別實作抽象類別不想影響本身實作類別的函式或方法 在抽象類別的實作中，用 super 的方式建構抽象類別加入的類別實體，並為其做使用 特色: 在抽象類別之間，建立一個聯絡的橋樑做互動，其各自的的實體可藉由建立的橋樑進行互動，同時可保持各自的獨立性 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:6","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#bridge"},{"categories":["learning-note"],"content":" Flyweight Practice code in TypeScrpt : Flyweight pattern 概念: 為降低系統負荷，讓物件的某些屬性可以隨著需求隨時做變化 在類別中區分外在屬性與內部屬性 內部屬性由所有類別所共用 外部屬性則可以依照需求而置換屬性內容 建立一個產生類別實體的工廠，用來生產相同類別但不同內部屬性內容的實體，並管理取得各種實體產生的方式 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:3:7","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#flyweight"},{"categories":["learning-note"],"content":" Behavioral Patterns","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:0","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#behavioral-patterns"},{"categories":["learning-note"],"content":" Strategy Practice code in TypeScrpt : Strategy pattern 概念: 將各種不同的策略(演算法)，包裝成類別，以便在需要時可快速切換不同的策略 方法: 建立呼叫策略方法的介面 實作不同的策略類別 在需要使用多個策略的類別中，加入呼叫策略的方法 切換不同策略時，直接帶入所需策略的實體，即可使用該策略 與工廠模式的差異 factory pattern : 專注於如何去建立物件，而非使用 strategy pattern : 專注於依照當前所需，由外部帶入不同的策略做使用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:1","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#strategy"},{"categories":["learning-note"],"content":" Observer Practice code in TypeScrpt : Observer pattern 概念: 在觀察者(observer) 介面中，提供方法供被觀察者(subject)一次呼叫多個實作其介面的類別，用於處理物件之間一對多的連動關係 方法: 建立 obserser 介面，提供被呼叫 or 觸發時對應的方法 依照不同的需求，實作被觸發時，對應的做法 在一個被觀察的物件 (subject) 中, 建立一個可以觸發 observer 的方法，達到一對多的連動與互動的效果 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:2","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#observer"},{"categories":["learning-note"],"content":" Command Practice code in TypeScrpt : Command pattern 概念: 將 command(request) 封裝成不同的物件形式,用於分源分流處理不同的 command(request) 方法: 建立 receiver 介面方法，並依照需做分別去實作 建立 command 介面，實作可接收 receviver 實體，與呼叫該 receiver 方法的類別 建立 invoker 類別，呼叫不同的 command 特色: 建立一個中介的角色 invoker, 用來轉接所有的 command 給對應的 receiver invoker 可將不同的 command 進行處理的優先順序排列 invoker 可自行控管不同 receiver 可接收的 coomand 數量, 也可取消未處理的 command invoker 可將不同的 command 進行處理的優先順序排列 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:3","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#command"},{"categories":["learning-note"],"content":" Template Practice code in TypeScrpt : Template pattern 概念: 定義一套方法或流程(演算法)的結構，但實作的細節則由實作的子類別去實現，並藉由 hook 去切換不同的實作方法 方法: 定義一個實體作為 template 的 input, 供 template 類別改變其內容 定義 template 介面方法，表達演算法的結構 實作介面演算法結構的 template 類別實體 在 template 實體中，加入 hook，用來判定如何切換不同的 template 實體 定義 function 函式，用來將 input 套用在當下的 template，並返回與 input 相同的類別，供給下一次套用 template 使用 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:4","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#template"},{"categories":["learning-note"],"content":" State Practice code in TypeScrpt : State pattern 概念: 讓物件的不同狀態封裝成各式的類別，用來表達物件會隨著不同狀態而有著不同的行為 方法: 在一個需要表達不同狀態的物件中，定義一個可切換當前屬性狀態的函式 定義不同 state 物件，接收當前須改變的狀態物件，改變其屬性狀態 在不同 state 物件中，插入可以再變更成另一種 state 物件的條件方式，用於再使 input 物件，切換成不同的狀態物件 特色: React framework 中藉著 state 監聽資料的狀態變化，渲染不同的 UI 畫面 Redux, Vuex, Pinia 等前端狀態管理工具，都可有效率管控不同的資料狀態被改變的方式與來源，以確保每一個狀態的改變都可以被追蹤 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:5","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#state"},{"categories":["learning-note"],"content":" Chain Of Responsibility Practice code in TypeScrpt : Chain Of Responsibility pattern 概念: 定義一個介面函式，讓不同的物件處理 (實作) 同一個請求 (request)，並讓實作介面者(handler) 在達成特定條件下傳遞給另一個 handler 處理相同的請求 方法: 將請求 (request) 這個動作封裝成一個類別，並設置可傳遞給不同 handler 呼叫的條件屬性與對應的存取函示，即定義一個責任鏈(chain of resposibility) 將可處理 request 的 handler 抽象成一個介面(抽象類別)，並在初始化中，放入在達成請求時，下個處理相同請求的 handler 實作 handler 的抽象類別，定義應對請求方式的條件，並處理請求 特色: 相較 if else 的方式，包裝在達成條件下，呼叫相關的實體處理相同的請求，使用此 pattern 可以在不更動 hanlder 前提下，藉由更動 request 的屬性，設置可以傳達到某一個責任鏈階段的 handler ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:6","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#chain-of-responsibility"},{"categories":["learning-note"],"content":" Interpreter Practice code in TypeScrpt : Interpreter pattern 概念: 一系列的翻譯工具、解譯器，用來表達或轉換輸入的語言文字意思 方法: 定義轉換輸入的界面函示，然後實作各式的翻譯方法 走訪輸入的文字並設置不同的條件，用以切換不同的翻譯方法 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:7","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#interpreter"},{"categories":["learning-note"],"content":" Mediator Practice code in TypeScrpt : Mediator pattern 概念: 一個中介(mediator)物件，用來傳遞、管理多個物件的交互作用 方法: 定義 mediator 的屬性，用來區分接收物件的角色 (eg: 用不同的 list 存放不同的物件) 定義 mediator 的靜態方法 (static method)， 用來存放所有需要交互的物件 定義 mediator 擁有交互物件所持有的交互方法，在交互物件需要進行交互時，由 mediator 進行實際上的交互作用 特色: 當多個物件具有交互作用時，可使用中介當任中間的傳遞角色，降低交互物件之間的耦合性 如同聊天軟體的角色，說話的雙方並非直接交談，而是透過軟體，將雙方要傳遞的話語，進行搜集並傳遞給雙方 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:8","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#mediator"},{"categories":["learning-note"],"content":" Memento Practice code in TypeScrpt : Memento pattern 概念: 備份、備忘錄，將物件的屬性，用另一個物件作儲存，使之可以隨時被調用，用以還原物件的狀態 方法: 建立一個備忘錄的物件 (memento) 其屬性包含所有要備份物件 (originator) 的屬性 在 originator 的函式中，建立存取 memento 的方法函示 另外再建立一個 recorder 存放所有的 memento，並建立每個 memento 被 originator 存取的方式與順序 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:9","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#memento"},{"categories":["learning-note"],"content":" Visitor Practice code in TypeScrpt : Visitor pattern 概念: 在實作相同抽象的實體群集中(collation)，使用不同的 visitor 呼叫抽象中定義的函式，讓群集中所有的實體去個別執行其實作的方法 在抽象類別中 (abstract class)，定義抽象函示 (abstract function)，由繼承的類別依照各自的需求實作 建立一個 collation 類別存放所有實作繼承抽象類別的實體 建立 vistor 抽象的介面，其中定義相同名稱的函式，供 collation 內的實體在實作的抽象函式中進行呼叫 在實作 vistor 介面的類別中，使用多載 (overload) 方式，定義 collation 中各個實體的執行方式 特色: visitor 將物件的行為做封裝，讓個別物件在 collation 中能保留各自的特性 ","date":"2022-12-31","objectID":"/my-hugo-blog/ts-design-pattern/:4:10","series":[""],"tags":null,"title":"Design Patterns in TypeScript","uri":"/my-hugo-blog/ts-design-pattern/#visitor"},{"categories":["book-reading"],"content":"ISBN 978-986-137-330-0 (1.創造性思考) ","date":"2022-12-08","objectID":"/my-hugo-blog/isbn-978-986-137-330-0/:0:0","series":[""],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 思考の整理學 :最多東大生、京大生讀過的一本書!","uri":"/my-hugo-blog/isbn-978-986-137-330-0/#"},{"categories":["book-reading"],"content":" 思考整理的三個筆記本 隨身筆記本 用途：記錄稍縱即逝的想法或靈感 紀錄順序： 想法編號 (日後參照用) 主要內容 日期 (日後參照用) 畫底線做區隔 過渡期筆記本 用途：移植隨身筆記本中沒有腐爛、死亡的想法，讓想法繼續沈澱 紀錄順序： 標題 (提示是關於什麼的想法) 條列式整理內容 日期 (轉移日期) 編號 (隨身筆記本編號) 相關資料 超筆記本 用途：紀錄並長久沈澱的後仍存活的想法，並加入新的思考靈感 紀錄順序：(需要跨頁記錄，一個跨頁一個主題) (左)：流水編號 (左)：主題 (左)：轉移日期 (左)：編號 (過渡期筆記本編號) (左)：條列式整理內容(內容太多跨頁可用底線做區隔) (右)：重新整理過發現的新線索或靈感 警語：因為是重要，且需長期關注的想法，不可天天翻閱 ","date":"2022-12-08","objectID":"/my-hugo-blog/isbn-978-986-137-330-0/:1:0","series":[""],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 思考の整理學 :最多東大生、京大生讀過的一本書!","uri":"/my-hugo-blog/isbn-978-986-137-330-0/#思考整理的三個筆記本"},{"categories":["book-reading"],"content":" 佳句｜心得節錄 無個性說(impersonal theory): 詩人的個性不會直接表現出來，而是扮演催化劑，讓他的東西發生化學變化，如此一來才是真正的個性化 eg: 古詩、日本俳句，將主觀想法寄託風花雪月，以間接的方式表達想法 大部分的點子或想法，都是從既存的事物中彼此激盪連結而產生的 類比法是解答未知為題的良方，利用數學比例法，用已知去聯想未知 利用電影底片的方法，將一張張靜態畫面連續放映、重疊所產生的“後象”原理，一次閱讀全貌，較容易豁然開朗理解內容 練習以一句話歸納想法 ","date":"2022-12-08","objectID":"/my-hugo-blog/isbn-978-986-137-330-0/:2:0","series":[""],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 思考の整理學 :最多東大生、京大生讀過的一本書!","uri":"/my-hugo-blog/isbn-978-986-137-330-0/#佳句心得節錄"},{"categories":["book-reading"],"content":"ISBN 978-986-434-784-1 (1.物件導向 2.軟體研發) ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:0:0","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#"},{"categories":["book-reading"],"content":" 物件導向理論","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:0","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件導向理論"},{"categories":["book-reading"],"content":" 類別(class) 概念：一組相似事物的統稱 一組：多個 相似：比較像，但不完全相同 統稱：通稱，概括多個事物 劃分方法：站在個人的觀察角度，察覺有相似的事物就是同一類 組成： 屬性：類別的特性 原則：最小化原則，將屬性切到無法在分割為止 方法：類別的功能 原則：單一化原則，一個方法只做一件事 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:1","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#類別class"},{"categories":["book-reading"],"content":" 物件(object) 概念：一個具體、真實存在的類別 (軟體)物件產生的流程方法 (水果 -\u003e 蘋果、香蕉) 現實物件：可觀察到現實存在的物體 現實類別：對現實物體的歸納總結 軟體物件：軟體運行時的實體 軟體類別：軟體設計過程中的歸納總結而成的分類 觀察現實存在的物件，歸納概括成現實的類別 根據現實的類別，在軟體設計的過程中，歸納總結的分類成果 實體化在軟體運行中的實體 實作技巧 概念：電影來自生活，但高於生活 =\u003e 軟體類別來自現實類別，但高於現實類別 可以用多個軟體類別，組成一個對應的現實類別 (可不用一對一) eg: (現實類別) ATM 功能 = (軟體類別) ATM 餘額查詢 ＋ ATM 取款 ＋ ATM 存款 軟體類別因為是抽象模擬的 “概念”，所以並不一定存於現實中 eg: 策略 strategy，工作流程 workflow ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:2","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件object"},{"categories":["book-reading"],"content":" 介面(interface) 概念：一組相關、有互動功能的點集合 inter：互相，兩方的互動 face：面，點的集合，相對應於點、線 定義概念拆解： 相關：彼此相關的功能作用，eg: USB 介面、網路介面、 互動：可作用於不同物體之間的互動，非單一方面 定義：只做定義，但不涉具體實作 =\u003e 一個互動雙方的“約定”，具體的實作方式由實際互動方制定即可 集合：多個功能點的集合，非一個具體的功能點 特性： 在希望某群物件有共同的屬性或功能下使用 在不清楚某群物件是否屬於同一個類別下使用 eg: 在面對處理的物體是動物，但又希望這個動物按照所需求的方式進行活動 (人、狗、其他動物) ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:3","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#介面interface"},{"categories":["book-reading"],"content":" 抽象(abstract) 概念：抽取比較像的部分出來 結合物件的概念：抽取多個物件或類別中比較像的部分 特性： 可劃分具有“相似”的類別 主要目的：隔離關注點，降低複雜度 主要用於發現新類別的方法 =\u003e 先抽象共同點，在拉出一個新的類別 eg: (developer,maintainer)=\u003e people, (developer,dog) =\u003e animal ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:4","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#抽象abstract"},{"categories":["book-reading"],"content":" 抽象類別(abstract class) 概念：根據類別共有的特性，再進行抽取比較像的部分 特性： 本質上還是類別，但只能用於繼承，無法用來產生實體的物件 相對於普通的軟體類別由現實類別抽象模擬而出，抽象類別則是更高級的抽象 抽象類別是由普通軟體類別抽象模擬而成 eg: 吃“水果”(抽象類別)，實際上是吃“蘋果、香蕉”(普通類別) 同時具備普通類別與介面的部分特性，為介於兩者之間的概念 與普通類別的差異： 繼承： 普通類別：子類別透過繼承父類別，即可獲得父類別的方法 抽象類別：若有定義抽象方法(只有宣告，但沒有實作)，則子類別需要自己去實作方法 與介面的差異： 概念： 介面：強調物件之間的相似性，但僅限於方法宣告，缺少定義上的相似 抽象類別：為類別，強調一組事物的相似性，包含屬性與方法 實作： 介面：需要逐一實作個別物件的屬性與方法 抽象類別：若有定義抽象方法，則需要為繼承的物件個別實作 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:5","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#抽象類別abstract-class"},{"categories":["book-reading"],"content":" 物件導向核心特徵 封裝 (encapsulation) 概念：使用類別，將一組相似事物的特性與行為包裝起來 作用： 保護隱私 對類別內個屬性的修改，只能通過內部的類別方法存取 隔離複雜度 個別類別只需負責自己的實作功能即可 類別外在的使用者，只需呼叫類別提供的方法即可，不需了解其內部的實作方法 方法： public：不進行封裝，直接對外公開 protected：只對 child,與 friend 類別公開 private：完全不公開 繼承 (inheritance) 概念：遺傳，承襲 parent 的特性與行為 與抽象的差異 抽象: 分析和設計過程的一個動作、一個技巧，透過抽象出類別 繼承: 實作過程的一個動作，根據抽象的結果，透過程式語言的特性，完成抽象的模擬 抽象與繼承的關係：“承先啟後”，先有抽象，再由抽象得出類別，最後由繼承表達抽象的結果 多型(polymorphism) 概念：“多胎”，使用指向父類別的指標或參考，便能呼叫子類別的物件 特性： 遮罩對於子物件的差異，允許呼叫者撰寫通用性的程式碼 當呼叫函式時，帶入指定為 parent 的類型時，可以帶入 children 的物件屬性，並在內部使用 parent 定義的函式 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:1:6","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件導向核心特徵"},{"categories":["book-reading"],"content":" 物件導向方法","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:0","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件導向方法"},{"categories":["book-reading"],"content":" 物件導向開發流程 需求模型：透過和客戶溝通，結合行業經驗和知識，明確刻畫客戶的需求 領域模型：根據需求模型，提煉出領域相關的概念，為後面的物件導向設計打下基礎 設計模型：以領域模型為基礎，綜合物件導向的各種設計技巧，完成類別的設計 實作模型：以設計模型為基礎，將設計模型轉譯為具體的語言實作，完成程式碼的撰寫 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:1","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件導向開發流程"},{"categories":["book-reading"],"content":" 需求模型","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:2","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#需求模型"},{"categories":["book-reading"],"content":" 領域模型","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:3","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#領域模型"},{"categories":["book-reading"],"content":" 設計模型","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:4","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#設計模型"},{"categories":["book-reading"],"content":" 實作模型","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:2:5","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#實作模型"},{"categories":["book-reading"],"content":" 物件導向技巧","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:3:0","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#物件導向技巧"},{"categories":["book-reading"],"content":" 設計原則 內聚(Cohesion) 概念：“凝聚力”，模組 (函數、類別、套件、子系統) 內的元素，是否都專注於模組所賦予的職責 較佳的內聚形式：功能內聚 案例概念：進行 CRUD 操作的類別，內部的元素間雖沒相關互動，但皆專注於資料的操作與存取 耦合(Coupling)、依賴(Dependency) 概念：模組間的依賴程度，某個模組Ａ使用了另一個模組Ｂ的元素完成特定功能 最差的耦合形式：內容耦合 概念：模組Ｂ修改模組Ａ所依賴的內容(屬性)時，模組Ａ跟模組Ｂ都必須同步修改 設計原則：高內聚低耦合 目的：降低複雜性 反向思維：低內聚 or 高耦合 會使系統產生較多的不確性，即不穩定 實作想法：在高內聚與低耦合間取得平衡，不偏向任何一端 類別設計原則 S.O.L.I.D. principle SRP (Single Responsibility Principle, 單一職責原則) 概念：一組類別只需負責一組 “相關” 的事, 即一個類別有多個方法，且相互關聯 職責定義： 由其他的類別視角來決定 包含多個相關的功能 適用範圍：基礎類別 不適用範圍 : 聚合類別 (根據基礎類別建構的複雜結構)。 解法：優先使用多物件作組合，而非類別繼承 應用場景：用於類別的設計 OCP (Open-Closed Principle, 開放封閉原則) 概念：在使用者不改變操作方法的條件下，提供者增加新的功能 含義：對提供者(provider)開放擴充，對使用者(consumer)關閉修改 (open for provider extension, closed for consumer modification) 適用原則：定義相同的介面(provider)進行實作(consumer實作)，即 “透過介面進行互動” 適用範圍： 類別之間使用 interface 互動 模組和模組、系統和系統之間使用 協定 互動，ex: HTTP, SOAP 應用場景：整體架構的設計 一般能符合 LSP、ISP、DIP，則可符合 OCP LSP (Liskov Substitution Principle, Liskov 替換原則) 概念：定義子類別物件繼承來自父類別的規範 子類別必須實作 or 繼承父類別所有的公有方法 (public method) 子類別每個方法的 input 參數必須與父類別方法一致，eg: 應用使用 “多型” 時，大多是定義父類別作為 input 的參數 子類別每個方法的 output 必須多於父類別 (至少能完成父類別定義的輸出) 適用原則：專注於定義方法相同的 input 與 output，但不包含其中的過程 應用場景：用於類別的繼承，與 DIP 相輔相成，由 interface、abstract class 衍生出新的子類別 ISP (Interface Seggregation Principle, 介面隔離原則) 概念：類別內有使用到的介面，應該照個別使用需求去呼叫，而非使用單一個大而全面的介面 含義：物件內需要非內聚的介面，consumer 不需要知道整個類別，只需要知道有內聚介面的抽象父類別即可 適用原則：不應該強迫 consumer 依賴不需要的介面，即 consumer 只使用剛剛好的依賴介面 應用場景：用於介面的設計 DIP (Dependency Inversion Principle, 依賴反轉原則) 概念：使用抽象的方法，將類別間的依賴、耦合性降低 含義：(底層模組：一個完整無法再分割的邏輯，高層模組：表達的邏輯是由多個底層模組成) 高層模組不應該直接依賴底層模組，兩個都應該依賴抽象層 抽象不能依賴細節，細節(實作)必須依賴抽象(定義) 應用場景：用於提取出抽象，即抽出共同、相似的部分，形成 interface、abstract class、 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:3:1","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#設計原則"},{"categories":["book-reading"],"content":" 設計原則 內聚(Cohesion) 概念：“凝聚力”，模組 (函數、類別、套件、子系統) 內的元素，是否都專注於模組所賦予的職責 較佳的內聚形式：功能內聚 案例概念：進行 CRUD 操作的類別，內部的元素間雖沒相關互動，但皆專注於資料的操作與存取 耦合(Coupling)、依賴(Dependency) 概念：模組間的依賴程度，某個模組Ａ使用了另一個模組Ｂ的元素完成特定功能 最差的耦合形式：內容耦合 概念：模組Ｂ修改模組Ａ所依賴的內容(屬性)時，模組Ａ跟模組Ｂ都必須同步修改 設計原則：高內聚低耦合 目的：降低複雜性 反向思維：低內聚 or 高耦合 會使系統產生較多的不確性，即不穩定 實作想法：在高內聚與低耦合間取得平衡，不偏向任何一端 類別設計原則 S.O.L.I.D. principle SRP (Single Responsibility Principle, 單一職責原則) 概念：一組類別只需負責一組 “相關” 的事, 即一個類別有多個方法，且相互關聯 職責定義： 由其他的類別視角來決定 包含多個相關的功能 適用範圍：基礎類別 不適用範圍 : 聚合類別 (根據基礎類別建構的複雜結構)。 解法：優先使用多物件作組合，而非類別繼承 應用場景：用於類別的設計 OCP (Open-Closed Principle, 開放封閉原則) 概念：在使用者不改變操作方法的條件下，提供者增加新的功能 含義：對提供者(provider)開放擴充，對使用者(consumer)關閉修改 (open for provider extension, closed for consumer modification) 適用原則：定義相同的介面(provider)進行實作(consumer實作)，即 “透過介面進行互動” 適用範圍： 類別之間使用 interface 互動 模組和模組、系統和系統之間使用 協定 互動，ex: HTTP, SOAP 應用場景：整體架構的設計 一般能符合 LSP、ISP、DIP，則可符合 OCP LSP (Liskov Substitution Principle, Liskov 替換原則) 概念：定義子類別物件繼承來自父類別的規範 子類別必須實作 or 繼承父類別所有的公有方法 (public method) 子類別每個方法的 input 參數必須與父類別方法一致，eg: 應用使用 “多型” 時，大多是定義父類別作為 input 的參數 子類別每個方法的 output 必須多於父類別 (至少能完成父類別定義的輸出) 適用原則：專注於定義方法相同的 input 與 output，但不包含其中的過程 應用場景：用於類別的繼承，與 DIP 相輔相成，由 interface、abstract class 衍生出新的子類別 ISP (Interface Seggregation Principle, 介面隔離原則) 概念：類別內有使用到的介面，應該照個別使用需求去呼叫，而非使用單一個大而全面的介面 含義：物件內需要非內聚的介面，consumer 不需要知道整個類別，只需要知道有內聚介面的抽象父類別即可 適用原則：不應該強迫 consumer 依賴不需要的介面，即 consumer 只使用剛剛好的依賴介面 應用場景：用於介面的設計 DIP (Dependency Inversion Principle, 依賴反轉原則) 概念：使用抽象的方法，將類別間的依賴、耦合性降低 含義：(底層模組：一個完整無法再分割的邏輯，高層模組：表達的邏輯是由多個底層模組成) 高層模組不應該直接依賴底層模組，兩個都應該依賴抽象層 抽象不能依賴細節，細節(實作)必須依賴抽象(定義) 應用場景：用於提取出抽象，即抽出共同、相似的部分，形成 interface、abstract class、 ","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:3:1","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#類別設計原則-solid-principle"},{"categories":["book-reading"],"content":" 設計模式","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:3:2","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#設計模式"},{"categories":["book-reading"],"content":" UML","date":"2022-12-03","objectID":"/my-hugo-blog/isbn-978-986-434-784-1/:3:3","series":["object oriented","software development"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 編寫程式的邏輯: 如何用物件導向實作複雜的業務需求","uri":"/my-hugo-blog/isbn-978-986-434-784-1/#uml"},{"categories":["book-reading"],"content":"ISBN 978-957-8567-74-0 (1.睡眠 2.健康法) infomation 譯自： Sleep: The Myth of 8 Hours, the Power of Naps, and the New Plan to Recharge Your Body and Mind ","date":"2022-11-21","objectID":"/my-hugo-blog/sleep-r90/:0:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  世界第一的R90高效睡眠法：C羅、貝克漢的睡眠教練教你如何睡得少，也能表現得好","uri":"/my-hugo-blog/sleep-r90/#"},{"categories":["book-reading"],"content":" 佳句節錄 深層睡眠時間約莫在凌晨 2,3 點，別跟自己的身理時鐘作對 放慢晨間步調，睡眠品質從起床一刻開始就決定了。 Ｒ90 睡眠法 ~== 在九十分鐘內修復身心 睡眠週期 第一期非快速動眼期：樓梯頂端，逐漸入睡 第二期飛快速動眼期：樓梯中斷，淺層睡眠 (大部分時間處在的狀態) 第三期與第四期飛快速動眼期：樓梯底層，深層睡眠 (身體修復期) 快速動眼期 ： 螺旋滑梯，重回樓梯頂層，進入淺層睡眠 睡眠的品質取決於是否經歷一連串的睡眠週期 ","date":"2022-11-21","objectID":"/my-hugo-blog/sleep-r90/:1:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  世界第一的R90高效睡眠法：C羅、貝克漢的睡眠教練教你如何睡得少，也能表現得好","uri":"/my-hugo-blog/sleep-r90/#佳句節錄"},{"categories":["book-reading"],"content":" 睡眠策略 理想睡眠週期：35 個週期，最好不小於 28 個週期 降低身體溫度，準備睡眠 睡覺時用鼻子呼吸 午睡有沒有睡著不重要，利用閉眼，暫時脫離世界，修復疲勞 管制修復期： 13:00 ~ 15:00 : 彌補夜間睡眠不足，同步晝夜節律的最好方法 17:00 ~ 19:00 : 最多 30 分，以免影響夜間睡眠 改造睡眠： 用非慣用手一側側睡 檢測合適床墊：側躺時身體姿勢是否成一直線 床越大越好 讓臥室黑不見光，防止外來燈光干擾睡眠 讓臥室保持涼爽 ","date":"2022-11-21","objectID":"/my-hugo-blog/sleep-r90/:2:0","series":["life"],"tags":null,"title":"[ 心得｜摘要｜節錄 ]  世界第一的R90高效睡眠法：C羅、貝克漢的睡眠教練教你如何睡得少，也能表現得好","uri":"/my-hugo-blog/sleep-r90/#睡眠策略"},{"categories":["book-reading"],"content":"ISBN 978-957-32-9552-2 (1.溝通技巧 2.說話藝術) ","date":"2022-11-21","objectID":"/my-hugo-blog/isbn-978-957-32-9553-2/:0:0","series":["expression"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 表達力決定你是誰: 提升表達力，成為自己期待的樣子","uri":"/my-hugo-blog/isbn-978-957-32-9553-2/#"},{"categories":["book-reading"],"content":" 佳句節錄 [表達]，不是先想要說什麼，而是你想呈現什麼 [溝通]，不是先說你的看法，而是傾聽他的想法 [人緣]，不是覺得別人必須如何，而是理解沒人有義務如何 自信，是透過自己對自己的了解，相信且熱愛自己，才能夠發自內心地展現出自信的光芒 別讓他人的價值觀，影響了自己的人生 透過 [感謝 ＋ 接受 ＋ 提問] 去理解對方的動機，自然就會找到更輕鬆說服或引導對方思維的方向，反而不需要花太多力氣就能達到你要溝通的目的 這個想法很棒呢！ 原來還有這樣的思考方式 謝謝你的分享！ 不過我很好奇，你的資訊都是從哪邊得知的呢 你的每個狀態，都在告訴別人你是誰 越完整表達越能讓自己節省時間，且減少誤會 說話前想想看，我們講出這句話的時候，到底想要帶給別人什麼樣的感覺 有意識的對象感 [說話不是說給自己聽，而是說給別人聽] 眼睛要看對方：下巴要為微微抬高、平視角地看著對方 聲音要讓對方聽見：聲音要投射到對方身上，而非只是說出聲音 清楚的咬字發音：嘴巴要張大、認真咬字 如果可以，請先微笑在說話：這能讓聲音聽起來正向愉悅，而非嚴肅低沈 注意自己的表達狀態，不要急著說話而是先傾聽 [我以為、你認為]這樣[預設對方應該懂]，並無法提升溝通和做事的品質及效率。 最好的做法還是記錄下來，以及在溝通時多關心、多提問，寧願囉唆一點，也不要造成溝通誤解 當我們把焦點放在自己的[可控狀態]，並且正向主動出擊，就很有機會實現你想要的結局 提升好人緣的秘密 相信每個人都是善良的 沒有人有義務一定要對我們如何 健康的心態才能讓自己更加自在 NG 聊天開場白 說話沒頭沒尾 說話沒打招呼 內容沒有明確目的 直接切入正題 破冰聊天開場白 感謝對方 (感謝他抽空和你見面) 關心對方 (關心 路上塞車？、路線好找嗎？、近況？、天氣？) 讚美對方 (打扮、氣色、第三者對他的讚美) 提升好感度的三面向構通技巧 肢體語言 親切笑容 適當點頭(表示有在認真聽) 身體微微往前的積極感 (表示有興趣、好奇心) 不要雙手抱胸、背部貼在椅背上 如果可以的話，模仿對方的肢體動作(手勢) 聲音表情 咬字清楚，不要讓對方聽不懂或誤會 在對方分享時，適當加上[摁～喔～]的回應聲 (讓對方知道你有在聽) 如果可以的話，模仿對方的聲音語調(講話速度、聲調) 說話內容 多使用正向詞彙，尤其是感謝 適當稱讚對方 重複對方的內容 開放性的提問，表達出你的好奇心：你會做這個選擇，是因為背後有什麼原因或是想法嗎？ 提升說話邏輯的[漢堡架構] [麵包] =\u003e [開場白] : 禮貌加上問候語，開門見山說主題 [肉] =\u003e [重點] : 條列式說話重點，抓住主軸不離題 [菜] =\u003e [解釋｜舉例] : 加上解釋與舉例，說話理解更容易 [麵包] =\u003e [結尾] : 自信表達結尾，或表達期望對方採取什麼樣的行動 說話時選用[精準的正向詞彙]，這將會改變你看待世界和人生的方式 超暖心傾聽三部曲 想聽 看著對方 面帶微笑 適當回應 聽完 展現願意理解他人的一種貼心，有時候對方只想要一個分享的聽眾 有些人在說話的過程中，會自己梳理好真正的問題，不需要急著趕出意見或想法 聽懂 回應對方的 [情緒] 先回應對方的情緒，來確認你的感受，讓對方有被理解的感受 我覺得你現在有點情緒，是不是讓你感到很… 你覺得 … 是嗎？ 回應對方的 [資訊] 適當回應你聽到的內容，協助對方聚焦思路，使溝通更流暢 你的意思是 … 嗎？ 是因為 … 所以才 …… 嗎？ 我想先確認你想表達的意思是？ 做筆記 紀錄關鍵字、訊息，避免急於詢問而打岔對方 作者親自解說影片 : Youtube links ","date":"2022-11-21","objectID":"/my-hugo-blog/isbn-978-957-32-9553-2/:1:0","series":["expression"],"tags":null,"title":"[ 心得｜摘要｜節錄 ] 表達力決定你是誰: 提升表達力，成為自己期待的樣子","uri":"/my-hugo-blog/isbn-978-957-32-9553-2/#佳句節錄"},{"categories":null,"content":" About MeHi~ 我是 nofear195，目前是個前端工程師。 建立這個 Blog 的目的主要是在紀錄我有意識的成長歷程 不過還是怕健忘的我，可以快速複習我之前學啥ＱＡＱ，就當作是我個人的小抄天地ＸＤ ","date":"2022-10-16","objectID":"/my-hugo-blog/about/:1:0","series":null,"tags":null,"title":"About Me","uri":"/my-hugo-blog/about/#about-me"},{"categories":null,"content":" Article Industrial Control System Anomaly Detection and Classification Based on Network Traffic ","date":"2022-10-16","objectID":"/my-hugo-blog/about/:2:0","series":null,"tags":null,"title":"About Me","uri":"/my-hugo-blog/about/#article"},{"categories":null,"content":" Education Master degree from the Department of Computer Science and Information Engineering, National Central University Bachelor degree from the Department of Finance, Feng Chia University ","date":"2022-10-16","objectID":"/my-hugo-blog/about/:3:0","series":null,"tags":null,"title":"About Me","uri":"/my-hugo-blog/about/#education"},{"categories":["environment-build"],"content":"Hugo 踩坑紀錄 提示 以下建立方式皆以 Visual Studio Code Dev Containers extensioin 在獨立的 docker container 環境下建置完成 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:0:0","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#"},{"categories":["environment-build"],"content":" Setup (normal)","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:1:0","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#setup-normal"},{"categories":["environment-build"],"content":" github side 1 從 github 新增 repository 複製 repository HTTPS 連結 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:1:1","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#github-side-1"},{"categories":["environment-build"],"content":" vscode side vscode 上方工具列 View =\u003e Command Platte 搜尋 Dev Containers: Clone Repository in Container Volume… 貼上在 github 取得的 HTTPS 連結 環境選擇： 手動輸入 Hugo (Community) vscode 上方工具列 Terminal =\u003e New Termianl 開始用 terminal 建置 hugo 環境 # 查看 hugo 使否已建置好 hugo version # 新增 hugo site 於根目錄 . hugo new site . --force # 新增主題 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke # 設置 site 主題參數至 config.toml 檔案 echo theme = \\\"ananke\\\" \u003e\u003e config.toml # 新增文章 (draft:false) hugo new posts/my-first-post.md # 啟動本地端 server hugo server -D # 建置 public 靜態網頁 hugo -D 在 config.toml 的 baseURL 設置為之後 github.io 網址 eg: baseURL = “https://nofear195.github.io/my-hugo-blog/\" 新增 .github/workflows/gh-pages.yml 檔案(需要先手動新增 .github , workflows 資料夾) 在 gh-pages.ymal 內新增以下內容 name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/main' with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 將以上完成的內容 push 至 github 上 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:1:2","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#vscode-side"},{"categories":["environment-build"],"content":" github side 2 在該 repositoy 頁面的工具欄點選 settings =\u003e pages Source =\u003e Deploy form a branch Branch =\u003e gh-pages =\u003e /root ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:1:3","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#github-side-2"},{"categories":["environment-build"],"content":" Setup (for DoIt theme)","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:2:0","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#setup-for-doit-theme"},{"categories":["environment-build"],"content":" 前置環境配置 需更改 container 環境的 Hugo 版本 ： hugo -\u003e hugo_extend (主要是能支援將 .scss 轉換成 .css) 需更改的文件有 devcontainer.json \"name\": \"Hugo (Community)\", \"build\": { \"dockerfile\": \"Dockerfile\", \"args\": { // Update VARIANT to pick hugo variant. // Example variants: hugo, hugo_extended // Rebuild the container if it already exists to update. \"VARIANT\": \"hugo_extended\", // Update VERSION to pick a specific hugo version. // Example versions: latest, 0.73.0, 0,71.1 // Rebuild the container if it already exists to update. \"VERSION\": \"latest\", // Update NODE_VERSION to pick the Node.js version: 12, 14 \"NODE_VERSION\": \"14\" } }, Dockerfile # Update the NODE_VERSION arg in docker-compose.yml to pick a Node version: 18, 16, 14 ARG NODE_VERSION=16 FROM mcr.microsoft.com/vscode/devcontainers/javascript-node:0-${NODE_VERSION} # VARIANT can be either 'hugo' for the standard version or 'hugo_extended' for the extended version. ARG VARIANT=hugo_extended # VERSION can be either 'latest' or a specific version number ARG VERSION=latest 更改文件配置後重新 build container 即可套用 hugo_extend 環境 需依照 DoIt Theme 文件教學去設置 config.toml 檔案才能正常運行 運行指令 hugo serve --disableFastRender 啟動本地端 hugo server 並支援 hotreload 功能 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:2:1","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#前置環境配置"},{"categories":["environment-build"],"content":" 方法一 從 DoIt Theme 文件教學做設置 ＝\u003e DoIt basic setting ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:2:2","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#方法一"},{"categories":["environment-build"],"content":" 方法二 跳過正常建置程序 hugo new site . --force 直接建立 themes 資料夾 新增 submodule git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 複製 themes/DoIt 裡面的 exampleSite 至 根目錄 . 運行指令 hugo serve --disableFastRender 啟動本地端 hugo server 提示 方法二的步驟不限於 DoIt 主題，任何主題內含有 exampleSite 字眼的文件都可用這方法直接跑範例， 自己再依需求從從範例修改 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:2:3","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#方法二"},{"categories":["environment-build"],"content":" 細節紀錄 文章右側的目錄列表正常顯示需要在 config.toml 內 [params.page.toc] 其中一個參數設置 keepStatic = false Twikoo comment 留言板設置教學 : Twikoo 文档 用 Vercel 部署方式 ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:2:4","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#細節紀錄"},{"categories":["environment-build"],"content":" Others","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:3:0","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#others"},{"categories":["environment-build"],"content":" 刪除 .git config 內記錄有關 summodule 的資訊 可以先用 cat .git/config 查看 git config 資訊 使用時機 手動刪除 themes 內的 submodules 後又想重新下載時，因為 git.config 紀錄，出現下載失敗資訊 stack overflow 討論串連結 Deleting all Git cached submodules from repository 下面附上最佳解答，我實測有效的 code # deinit all submodules from .gitmodules git submodule deinit . # remove all submodules (`git rm`) from .gitmodules git submodule | cut -c43- | while read -r line; do (git rm \"$line\"); done # delete all submodule sections from .git/config (`git config --local --remove-section`) by fetching those from .git/config git config --local -l | grep submodule | sed -e 's/^\\(submodule\\.[^.]*\\)\\(.*\\)/\\1/g' | while read -r line; do (git config --local --remove-section \"$line\"); done # manually remove leftovers rm .gitmodules rm -rf .git/modules ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:3:1","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#刪除-git-config-內記錄有關-summodule-的資訊"},{"categories":["environment-build"],"content":" 後記 總算把 github page 建起來，並套上 hugo 框架，真的好不容易啊，只能說好多坑，所以先把還記得都列上去了，之後有想到再新增吧 XD ","date":"2022-10-16","objectID":"/my-hugo-blog/hugo-setting/:3:2","series":["blog-setting"],"tags":["hugo"],"title":"Hugo setting","uri":"/my-hugo-blog/hugo-setting/#後記"}]